
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<title>CPU Scheduling Simulator</title>
	<!-- Bootstrap CSS file -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
	<title>Ground Reference Simulator</title>
</head>
<body>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>

<script src="simulator/sim.js"></script>
<script src="schedulers/fifo.js"></script>


<header class="page-header header container-fluid" style="text-align:center">
CPU Scheduler Simulator
</header>

<style>
	/* Tooltip container */
	.tooltip {
	  position: relative;
	  display: inline-block;
	  border-bottom: 1px dotted black; /* If you want dots under the hoverable text */
	}
	
	/* Tooltip text */
	.tooltip .tooltiptext {
	  visibility: hidden;
	  width: 120px;
	  background-color: black;
	  color: #fff;
	  text-align: center;
	  padding: 5px 0;
	  border-radius: 6px;
	 
	  /* Position the tooltip text - see examples below! */
	  position: absolute;
	  z-index: 1;
	}
	
	/* Show the tooltip text when you mouse over the tooltip container */
	.tooltip:hover .tooltiptext {
	  visibility: visible;
	}

	.scheduler {
		border: 2px solid black;
		border-radius: 10px;
		text-align: center;
	}
	.schedulertitle {
		color: white;
		background-color: gray;
	}
	.schedulersubtitle {
		color: black;
		background-color: lightgray;
	}
	/* .queues {
		border: 2px solid gray;
		border-radius: 10px;
	} */
	.border {
		border: 2px solid gray;
		border-radius: 10px;
	}
</style>


<div class="row" style="text-align:center">
	<div class="col-md-12">

		<input type="button" class="postsim" value="Reset" style="border-radius: 6px;" onclick="resetSimulation();">
	</div>
</div>

<div class="row" style="text-align:center">
	<div class="col-6">
		<input type="range" class="presim" id="max_jobs_slider" min="1" max="100" onchange="document.getElementById('#max_jobs_label').innerHTML = this.value;">Processes:<span id="#max_jobs_label"></span><br/>
		<input type="range" class="presim" id="max_jobs_slider" min="1" max="10" onchange="document.getElementById('#load_label').innerHTML = this.value;">Load:<span id="#load_label"></span><br/>
		<input type="range" class="presim" id="max_jobs_slider" min="1" max="99" onchange="document.getElementById('#waitpct_label').innerHTML = this.value;">Wait ratio:<span id="#waitpct_label"></span>%
	</div>
	<div class="col-6">
		System Type:
		<select id="#system_type_selector" name="system_type" class="presim" onchange="systemChanged();"></select>
	</div>
</div>
<div class="row" style="text-align:center">
	<div class="col">
		<input type="button" class="presim" value="Run" style="border-radius: 6px;" onclick="runSimulation();">
		<div id="#time_slice">Time Slice: </div>
	</div>
</div>

<div class="row" style="text-align:center">
	<div class="col-md-12">
		<input type="button" class="postsim" id="rev_all" value="|<<" style="border-radius: 6px;" onclick="revAll();">
		<input type="button" class="postsim" id="rev_ten" value="10<" style="border-radius: 6px;" onclick="adjustTimeSlice(-10);">
		<input type="button" class="postsim" id="rev_one" value="1<" style="border-radius: 6px;" onclick="adjustTimeSlice(-1);">
		<input type="button" class="postsim" id="fwd_one" value=">1" style="border-radius: 6px;" onclick="adjustTimeSlice(1);">
		<input type="button" class="postsim" id="fwd_ten" value=">10" style="border-radius: 6px;" onclick="adjustTimeSlice(10);">
		<input type="button" class="postsim" id="fwd_all" value=">>|" style="border-radius: 6px;" onclick="fwdAll();">
	</div>
</div>

<!-- The schedulers all get added here -->
<div class="container" id="#schedulers">
</div>

<script>
	let systems = [ 
		new System("1-CPU System", 1),
		new System("2-CPU System", 2),
		new System("4-CPU System", 4),
	]

	let colorings = [ 
		"CPU",
		"Priority",
		"Latency",
	]

	let colors = [
		"#AF0000", "#00AF00", "#0000AF",
		"#AFAF00", "#AF00AF", "#00AFAF",
	]

	var time_slice = 0
	let schedulers = []
	var traces = [] // Here is where we'll store the traces from the schedulers
	var runtimes = [] // How long each scheduler took to complete everything
	var max_runtime // The longest of the runtimes
	var rng_seed = 55

	resetSimulation();
	populateSystemSelector();

	addScheduler(new FIFOScheduler("FIFO Scheduler", getSelectedSystem()))
	addScheduler(new RRScheduler("Round Robin Scheduler", getSelectedSystem(), 3))
	addScheduler(new RandomScheduler("Random Scheduler", getSelectedSystem(), rng_seed))
	addScheduler(new MultiFIFOScheduler("MultiFIFOScheduler Scheduler", getSelectedSystem()))
	addScheduler(new PriorityScheduler("PriorityScheduler Scheduler", getSelectedSystem()))

	function addScheduler(scheduler) {
		schedulers.push(scheduler)
		appendSchedulerUI(scheduler, schedulers.length-1)
	}

	function systemChanged() {
		// Notify schedulers that the system has changed (as some may need to change their queues)
		for(scheduler_num=0; scheduler_num<schedulers.length; scheduler_num++) {
			rebuildUICpuColumn(scheduler_num)
			// We must notify all schedulers of the new system and _then_ ask them
			// about their queues
			schedulers[scheduler_num].setSystem(getSelectedSystem())
			rebuildUIQueueColumn(scheduler_num)
			rebuildUISchedulerCpuTapes(scheduler_num, getSelectedSystem())
		}
		// Now, rebuild the queues column for each scheduler's UI, in case their queues changed
		// TODO
	}

	////////////////////////////////////////////////////////////////
	// Viewer control (fwd/rev)
	////////////////////////////////////////////////////////////////
	function adjustTimeSlice(offset) {
		console.log("Adjusting time slice by " + offset)
		time_slice += offset
		if (time_slice < 0) { time_slice = 0 }
		if (time_slice > max_runtime) { time_slice = max_runtime }
		console.log("time_slice is now " + time_slice)
		console.log("Scheduler[0]'s trace for this cycle is now : " + JSON.stringify(traces[0].trace_object_list[time_slice]))
		updateUI()
	}

	// Rewind to the beginning
	function revAll() {
		adjustTimeSlice(-time_slice)
	}

	// Fast-forward to the end
	function fwdAll() {
		adjustTimeSlice(max_runtime - time_slice)
	}

	function updateUI() {
		// console.log("schedulers has " + schedulers.length + " items: " + JSON.stringify(schedulers))
		updateUITimeSlice()
		// Update each scheduler with the details of this time_slice
		for(scheduler_num=0; scheduler_num<schedulers.length; scheduler_num++) {
			updateUISchedulerQueues(scheduler_num)
			updateUISchedulerCpus(scheduler_num)
			updateUISchedulerTapes(scheduler_num)
		}
	}

	function updateUITimeSlice() {
		document.getElementById("#time_slice").innerHTML = "Time Slice : " + time_slice
	}

	function getSelectedSystem() {
		let systemTypeSelector = document.getElementById("#system_type_selector")
		// console.log("System Type Selector index = " + systemTypeSelector.selectedIndex)
		return systems[systemTypeSelector.selectedIndex]
	}

	function getProcessBoxForCpu(process) {
		var new_element = document.createElement("div")
		new_element.className = "border"
		new_element.style.minHeight = "30px"
		if (process == null) {
			new_element.appendChild(document.createTextNode("NONE"))
		} else {
			new_element.style.color = colors[process.job_number % colors.length]
			new_element.appendChild(document.createTextNode("P" + process.job_number))
		}
		return new_element
	}

	function getProcessBoxForQueue(process) {
		let process_element = document.createElement("div")
		process_element.className = "col-1 border"
		process_element.innerHTML = "P" + process.job_number
		process_element.style.color = colors[process.job_number % colors.length]
		return process_element
	}

	// Create a div describing this process, colorized and with optional style class and text for no process
	function getProcessDiv(process, nullText="", className="col border") {
		let process_element = document.createElement("div")
		process_element.className = className
		if (process != null) {
			process_element.innerHTML = "P" + process.job_number
			process_element.style.color = colors[process.job_number % colors.length]
		} else {
			process_element.innerHTML = nullText
		}
		return process_element
	}


	function getProcessBoxForTape(process) {
		let process_element = document.createElement("div")
		process_element.className = "col-1 border"
		process_element.innerHTML = "P" + process.job_number
		process_element.style.color = colors[process.job_number % colors.length]
		return process_element
	}

	function populateSystemSelector() {
		var selectBox = getAndEmptyElement("#system_type_selector")
		// var selectBox = document.getElementById("#system_type_selector")
		// // Clear existing box
		// while(selectBox.firstChild) {
		// 	selectBox.removeChild(selectBox.firstChild)
		// }
		for(i=0; i<systems.length; i++) {
			var new_option = document.createElement("option")
			new_option.value = i
			new_option.text = systems[i].name
			selectBox.appendChild(new_option)
		}
		selectBox.selectedIndex = 0
	}

	// function populateSchedulerSelector(scheduler_num) {
	// 	let id = `#scheduler_${scheduler_num}_selector`
	// 	console.log("ID = " + id)
	// 	var selectBox = document.getElementById(id)
	// 	// Clear existing box
	// 	while(selectBox.firstChild) {
	// 		selectBox.removeChild(selectBox.firstChild)
	// 	}
	// 	for(i=0; i<schedulers.length; i++) {
	// 		var new_option = document.createElement("option")
	// 		new_option.value = i
	// 		new_option.text = schedulers[i].name
	// 		selectBox.appendChild(new_option)
	// 	}
	// 	selectBox.selectedIndex = 0
	// }

	////////////////////////////////////////////////////////////////
	// ID generators
	////////////////////////////////////////////////////////////////
	function getSchedulerID(scheduler_num) { return `#scheduler_${scheduler_num}` }
	function getSchedulerCpusID(scheduler_num) { return `#scheduler_${scheduler_num}_cpus` }
	function getSchedulerCpuID(scheduler_num, cpu_num) { return `#scheduler_${scheduler_num}_cpu_${cpu_num}` }
	function getSchedulerQueuesID(scheduler_num) { return `#scheduler_${scheduler_num}_queues` }
	function getSchedulerQueueID(scheduler_num, queue_num) { return `#scheduler_${scheduler_num}_queue_${queue_num}` }
	function getSchedulerCurrentStatsID(scheduler_num, queue_num) { return `#scheduler_${scheduler_num}_currentstats` }
	function getSchedulerEndingStatsID(scheduler_num, queue_num) { return `#scheduler_${scheduler_num}_endingstats` }
	function getSchedulerTapesID(scheduler_num, cpu_num) { return `#scheduler_${scheduler_num}_tapes` }
	function getSchedulerTapePastID(scheduler_num, cpu_num) { return `#scheduler_${scheduler_num}_tape_${cpu_num}_past` }
	function getSchedulerTapePresentID(scheduler_num, cpu_num) { return `#scheduler_${scheduler_num}_tape_${cpu_num}_present` }
	function getSchedulerTapeFutureID(scheduler_num, cpu_num) { return `#scheduler_${scheduler_num}_tape_${cpu_num}_future` }

	////////////////////////////////////////////////////////////////
	// UI Update
	////////////////////////////////////////////////////////////////
	function getAndEmptyElement(element_id) {
		console.log("Getting and emptying element for : " + element_id);
		var element = document.getElementById(element_id)
		console.log("Got : " + JSON.stringify(element));
		while(element.firstChild) {
			element.removeChild(element.firstChild)
		}
		return element
	}

	function updateUISchedulerQueue(element_id, processes) {
		// console.log("We would update element " + element_id + " with " + processes.length + " processes")
		let element = getAndEmptyElement(element_id)
		var column_pad = document.createElement("div")
		column_pad.className = "col"
		element.appendChild(column_pad)
		// It's possible that, at later time-slices, this scheduler has already finished, in which case processes will be null
		// and we should just leave the queue blank
		if(processes != null) {
			// We have to reverse the list because the "front" of the queue is on the right
			for(process_num=processes.length-1; process_num >= 0; process_num--) {
				let process = processes[process_num]
				console.log("  process = " + JSON.stringify(process))
				element.appendChild(getProcessBoxForQueue(process))
			}
		}
	}

	function updateUISchedulerQueues(scheduler_num) {
		// Update all of the run queues
		console.log("Updating from scheduler " + scheduler_num)
		console.log("  " + JSON.stringify(schedulers[scheduler_num]))
		for(queue_num=0; queue_num<schedulers[scheduler_num].queue_names.length; queue_num++) {
			// If this scheduler finished before this time-slice, then pass a null so that the queue is displayed as empty
			let processes = null
			if(time_slice < traces[scheduler_num].trace_object_list.length) {
				processes = traces[scheduler_num].trace_object_list[time_slice].queues[queue_num]
			}
			updateUISchedulerQueue(getSchedulerQueueID(scheduler_num, queue_num), processes)
		}
		// Update the waiting list (which is numbered the next integer after the last run queue)
		let processes = null
		if(time_slice < traces[scheduler_num].trace_object_list.length) {
			processes = traces[scheduler_num].trace_object_list[time_slice].waiting_jobs
		}
		updateUISchedulerQueue(getSchedulerQueueID(scheduler_num, schedulers[scheduler_num].queue_names.length), processes)
	}

	
	function updateUISchedulerCpu(element_id, process) {
		console.log("updateUISchedulerCpu(" + element_id)
		let element = getAndEmptyElement(element_id)
		element.appendChild(document.createTextNode("CPU0"))
		console.log("  process = " + JSON.stringify(process))
		let process_element = document.createElement("div")
		process_element.className = "border"
		if (process == null) {
			process_element.innerHTML = "IDLE"
		} else {
			process_element.innerHTML = "P" + process.job_number
			process_element.style.color = colors[process.job_number % colors.length]
		}
		element.appendChild(process_element)
	}

	function updateUISchedulerCpus(scheduler_num) {
		for (cpu_num=0; cpu_num<getSelectedSystem().cpus; cpu_num++) {
			let process = null
			if (time_slice < traces[scheduler_num].trace_object_list.length) {
				process = traces[scheduler_num].trace_object_list[time_slice].assignments[cpu_num]
			}
			updateUISchedulerCpu(getSchedulerCpuID(scheduler_num, cpu_num),process)
		}
	}

	function rebuildUICpuColumn(scheduler_num) {
		let id = getSchedulerCpusID(scheduler_num)
		console.log("ID = " + id)
		let cpuBox = getAndEmptyElement(id)
		let title_bar = document.createElement("div")
		title_bar.className = "schedulersubtitle"
		title_bar.innerText = "CPUs"
		cpuBox.appendChild(title_bar)
		let selected_system = getSelectedSystem()
		console.log(JSON.stringify(selected_system))
		for(i=0; i<selected_system.cpus; i++) {
			console.log("Adding CPU"+i)
			var row_element = document.createElement("div")
			row_element.className = "row border"

			var new_element = document.createElement("div")
			new_element.className = "col border"
			new_element.id = `#scheduler_${scheduler_num}_cpu_${i}`
			new_element.appendChild(document.createTextNode("CPU" + i))
			new_element.appendChild(getProcessBoxForCpu("NOT RUNNING"))

			row_element.appendChild(new_element)

			cpuBox.appendChild(row_element)
		}
	}

	// Populate a single tape with the processes for this time-slice
	function updateUISchedulerTape(scheduler_num, cpu_num) {
		let TAPE_CAPACITY = 12 // This is a charateristic of Bootstrap, the HTML layout system we're using
		// Find the last time-slice for _this_ scheduler
		let max_time_slice = traces[scheduler_num].trace_object_list.length - 1

		// Do past tape
		var element_id = getSchedulerTapePastID(scheduler_num, cpu_num)
		var element = getAndEmptyElement(element_id)
		var row = document.createElement("div")
		row.className = "row"
		if (time_slice < TAPE_CAPACITY) {
			// There aren't enough processes to fill all 12 slots, so we need to pad
			let col = document.createElement("div")
			col.className = "col"
			row.appendChild(col)
		}
		for(i=Math.max(0,time_slice-TAPE_CAPACITY); i<time_slice; i++) {
			// In the case that this scheduler finished before others, we need to let this one
			// keep scrolling, so we need to pass null processes to getProcessDiv
			var process = null
			if(i <= max_time_slice) {
				process = traces[scheduler_num].trace_object_list[i].assignments[cpu_num]
			}
			let col = getProcessDiv(process, "", "col-1 border")
			row.appendChild(col)
		}
		element.appendChild(row)

		// Present tape
		element_id = getSchedulerTapePresentID(scheduler_num, cpu_num)
		element = getAndEmptyElement(element_id)
		if(time_slice <= max_time_slice) {
			row = document.createElement("div")
			row.className = "row"
			col = getProcessDiv(traces[scheduler_num].trace_object_list[time_slice].assignments[cpu_num])
			row.appendChild(col)
			element.appendChild(row)
		}

		// Future tape
		element_id = getSchedulerTapeFutureID(scheduler_num, cpu_num)
		element = getAndEmptyElement(element_id)
		var row = document.createElement("div")
		row.className = "row"
		for(i=time_slice+1; i<=Math.min(max_time_slice,time_slice+TAPE_CAPACITY); i++) {
			let col = getProcessDiv(traces[scheduler_num].trace_object_list[i].assignments[cpu_num], "", "col-1 border")
			row.appendChild(col)
		}
		if (time_slice + TAPE_CAPACITY < max_time_slice) {
			// There aren't enough processes to fill all 12 slots, so we need to pad
			let col = document.createElement("div")
			col.className = "col"
			row.appendChild(col)
		}
		element.appendChild(row)

	}

	// Populate all tapes for a given scheduler
	function updateUISchedulerTapes(scheduler_num) {
		// Update all of the tapes
		console.log("Updating tape on scheduler " + scheduler_num)
		console.log("  " + JSON.stringify(schedulers[scheduler_num]))
		for(cpu_num=0; cpu_num<getSelectedSystem().cpus; cpu_num++) {
			console.log("Doing the tape for cpu " + cpu_num)
			updateUISchedulerTape(scheduler_num, cpu_num)
		}
		// for(queue_num=0; queue_num<schedulers[scheduler_num].queue_names.length; queue_num++) {
		// 	console.log("trace queue for scheduler " + scheduler_num + " queues" + " are " + JSON.stringify(traces[scheduler_num].trace_object_list[time_slice].queues))
		// 	updateUISchedulerTape(
		// 		getSchedulerQueueID(scheduler_num, queue_num),
		// 		traces[scheduler_num].trace_object_list[time_slice].queues[queue_num]
		// 	)
		// }
		// Update the waiting list (which is numbered the next integer after the last run queue)
		// updateUISchedulerQueue(
		// 		getSchedulerQueueID(scheduler_num, schedulers[scheduler_num].queue_names.length),
		// 		traces[scheduler_num].trace_object_list[time_slice].waiting_jobs
		// )
	}

	////////////////////////////////////////////////////////////////
	// UI Rebuild 
	////////////////////////////////////////////////////////////////	
	function rebuildUIQueueColumn(scheduler_num) {
		let id = getSchedulerQueuesID(scheduler_num)
		console.log("ID = " + id)
		let queuesBox = getAndEmptyElement(id)
		let title_bar = document.createElement("div")
		title_bar.className = "schedulersubtitle"
		title_bar.innerText = "Queues"
		queuesBox.appendChild(title_bar)

		console.log("scheduler_num = " + scheduler_num)
		console.log("schedulers.length = " + schedulers.length)
		let scheduler = schedulers[scheduler_num]
		for(queue_num=0; queue_num<scheduler.queues.length; queue_num++) {
			queuesBox.appendChild(buildSchedulerQueue(scheduler_num, queue_num, scheduler.queue_names[queue_num]))
		}
		queuesBox.appendChild(buildSchedulerQueue(scheduler_num, scheduler.queues.length, "WAIT"))
	}

	function buildSchedulerQueue(scheduler_num, queue_num, queue_name) {
		let row = document.createElement("div")
		row.className = "row border"
		let name_col = document.createElement("div")
		name_col.className = "col-1 border"
		name_col.textContent = queue_name
		let queue_col = document.createElement("div")
		queue_col.className = "col-11 border"
		let queue_col_row = document.createElement("div")
		queue_col_row.className = "row"
		queue_col_row.id = getSchedulerQueueID(scheduler_num, queue_num)
		queue_col.appendChild(queue_col_row)
		row.appendChild(name_col)
		row.appendChild(queue_col)
		return row
	}

	function buildUISchedulerQueues(scheduler, scheduler_num) {
		var elements = []
		let title = document.createElement("div")
		title.className = "schedulersubtitle"
		elements.push(title)
		for(queue_num=0; queue_num<scheduler.queues.length; queue_num++) {
			elements.push(buildSchedulerQueue(scheduler_num, queue_num, scheduler.queue_names[queue_num]))
		}
		elements.push(buildSchedulerQueue(scheduler_num, scheduler.queues.length, "WAIT"))
		return elements
	}

	function buildUISchedulerQueuesAndCpus(scheduler, scheduler_num, system) {
		let queues_and_cpus = document.createElement("div")
		queues_and_cpus.className = "row border"
		let queues = document.createElement("div")
		queues.className = "col-10 border"
		queues.id = getSchedulerQueuesID(scheduler_num)
		// Build the whole queue stack
		// buildUISchedulerQueues(scheduler, scheduler_num).forEach((element) => queues.appendChild(element))
		let cpus = document.createElement("div")
		cpus.className = "col-2 border"
		cpus.id = getSchedulerCpusID(scheduler_num)
		queues_and_cpus.appendChild(queues)
		queues_and_cpus.appendChild(cpus)
		return queues_and_cpus
	}

	function buildUISchedulerCpuTape(scheduler_num, cpu_num) {
		let row = document.createElement("div")
		row.className = "row border"
		// CPU name
		var col = document.createElement("div")
		col.className = "col-1 border"
		col.textContent = "CPU" + cpu_num
		row.appendChild(col)
		// Left of play-head
		col = document.createElement("div")
		col.className = "col-5 border"
		col.id = getSchedulerTapePastID(scheduler_num, cpu_num)
		row.appendChild(col)
		// Play-head
		col = document.createElement("div")
		col.className = "col-1 border"
		col.id = getSchedulerTapePresentID(scheduler_num, cpu_num)
		row.appendChild(col)
		// Right of play-head
		col = document.createElement("div")
		col.className = "col-5 border"
		col.id = getSchedulerTapeFutureID(scheduler_num, cpu_num)
		row.appendChild(col)
		return row
	}

	function rebuildUISchedulerCpuTapes(scheduler_num, system) {
		let id = getSchedulerTapesID(scheduler_num)
		console.log("ID = " + id)
		let row = getAndEmptyElement(id)

		let row_col = document.createElement("div")
		row_col.className = "col"
		// Title divs
		let row_col_title = document.createElement("div")
		row_col_title.className = "row"
		let row_col_title_text = document.createElement("div")
		row_col_title_text.className = "col schedulersubtitle"
		row_col_title_text.innerText = "Tapes"
		row_col_title.appendChild(row_col_title_text)
		row_col.appendChild(row_col_title)

		for(cpu_num=0; cpu_num<system.cpus; cpu_num++) {
			row_col.appendChild(buildUISchedulerCpuTape(scheduler_num, cpu_num))
		}
		row.appendChild(row_col)
		return row
	}

	// This just builds the shell for the tapes. It gets populated by rebuildUISchedulerCpuTapes()
	function buildUISchedulerCpuTapes(scheduler_num) { 
		let row = document.createElement("div")
		row.className = "row border"
		row.id = getSchedulerTapesID(scheduler_num)
		return row
	}

	function buildUISchedulerStatistics(scheduler_num) {
		let row = document.createElement("div")
		row.className = "row border"
		let row_col = document.createElement("div")
		row_col.className = "col"
		// Title divs
		let row_col_title = document.createElement("div")
		row_col_title.className = "row"
		let row_col_title_text = document.createElement("div")
		row_col_title_text.className = "col schedulersubtitle"
		row_col_title_text.innerText = "Statistics"
		row_col_title.appendChild(row_col_title_text)
		
		// Row with stats columns
		let row_col_row = document.createElement("div")
		row_col_row.className = "row"
		let row_col_row_current = document.createElement("div")
		row_col_row_current.className = "col-6"
		row_col_row_current.id = getSchedulerCurrentStatsID(scheduler_num)
		row_col_row_current.innerText = "Current"
		var placeholder = document.createElement("div")
		placeholder.className = "border"
		placeholder.innerText = "Imagine some stats here"
		row_col_row_current.appendChild(placeholder)

		let row_col_row_ending = document.createElement("div")
		row_col_row_ending.className = "col-6"
		row_col_row_ending.id = getSchedulerEndingStatsID(scheduler_num)
		row_col_row_ending.innerText = "Ending"
		placeholder = document.createElement("div")
		placeholder.className = "border"
		placeholder.innerText = "Imagine some stats here"
		row_col_row_ending.appendChild(placeholder)

		row_col_row.appendChild(row_col_row_current)
		row_col_row.appendChild(row_col_row_ending)
		
		row_col.appendChild(row_col_title)
		row_col.appendChild(row_col_row)

		row.appendChild(row_col)

		return row
	}

	function appendSchedulerUI(scheduler, scheduler_num) {
		console.log("appendSchedulerUI(" + scheduler_num + ")")
		let scheduler_div = document.getElementById("#schedulers")
		let scheduler_row = document.createElement("div")
		scheduler_row.className = "row scheduler"
		let scheduler_container = document.createElement("div")
		scheduler_container.className = "container"
		let scheduler_title = document.createElement("div")
		scheduler_title.className = "schedulertitle"
		scheduler_title.textContent = scheduler.name
		// let queue_and_cpus = document.createElement("div")
		// queue_and_cpus.className = "row border"
		let queues_and_cpus = buildUISchedulerQueuesAndCpus(scheduler, scheduler_num, getSelectedSystem())
		let cpu_tapes = buildUISchedulerCpuTapes(scheduler_num, getSelectedSystem())
		let statistics = buildUISchedulerStatistics(scheduler_num)
		statistics.className = "row"
		scheduler_container.appendChild(scheduler_title)
		scheduler_container.appendChild(queues_and_cpus)
		scheduler_container.appendChild(cpu_tapes)
		scheduler_container.appendChild(statistics)
		scheduler_row.appendChild(scheduler_container)
		scheduler_div.appendChild(scheduler_row)
		scheduler_div.appendChild(document.createTextNode("|"))

		rebuildUICpuColumn(scheduler_num)
		rebuildUIQueueColumn(scheduler_num)
		rebuildUISchedulerCpuTapes(scheduler_num, getSelectedSystem())
	}


	////////////////////////////////////////////////////////////////
	// Simulation Reset/Run
	////////////////////////////////////////////////////////////////
	function resetSimulation() {
		// Disable any post-simulation UI elements and enable any pre-simulation ones
		var elements = document.querySelectorAll('.presim')
		elements.forEach((element) => element.disabled = false)
		var elements = document.querySelectorAll('.postsim')
		elements.forEach((element) => element.disabled = true)

	}

	function runSimulation() {
		// Disable any pre-simulation UI elements and enable any post-simulation ones
		var elements = document.querySelectorAll('.presim')
		elements.forEach((element) => element.disabled = true)
		var elements = document.querySelectorAll('.postsim')
		elements.forEach((element) => element.disabled = false)
		// TOOD: Actually call the simulator with parameters from the UI
		console.log("Running simulation")
		traces = simulator(getSelectedSystem(), schedulers, 55)
		max_runtime = 0
		for(i=0; i<traces.length; i++) {
			runtimes[i] = traces[i].trace_object_list.length
			// Find the largest runtime
			max_runtime = runtimes[i] > max_runtime ? runtimes[i] : max_runtime
		}

		console.log("There are " + (traces.length) + " traces")
		for (i=0; i<traces.length; i++) {
			console.log("Scheduler " + i + " needed " + traces[i].trace_object_list.length + " cycles")
		}
		time_slice = 0
		updateUI()

	}



</script>
</body>
</html>

