
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<title>CPU Scheduling Simulator</title>
	<!-- Bootstrap CSS file -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
	<title>Ground Reference Simulator</title>
</head>
<body>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>

<script src="simulator/sim.js"></script>
<script src="schedulers/fifo.js"></script>


<header class="page-header header container-fluid" style="text-align:center">
CPU Scheduler Simulator
</header>

<style>
	/* Tooltip container */
	.tooltip {
	  position: relative;
	  display: inline-block;
	  border-bottom: 1px dotted black; /* If you want dots under the hoverable text */
	}
	
	/* Tooltip text */
	.tooltip .tooltiptext {
	  visibility: hidden;
	  width: 120px;
	  background-color: black;
	  color: #fff;
	  text-align: center;
	  padding: 5px 0;
	  border-radius: 6px;
	 
	  /* Position the tooltip text - see examples below! */
	  position: absolute;
	  z-index: 1;
	}
	
	/* Show the tooltip text when you mouse over the tooltip container */
	.tooltip:hover .tooltiptext {
	  visibility: visible;
	}

	.scheduler {
		border: 2px solid black;
		border-radius: 10px;
		text-align: center;
	}
	.schedulertitle {
		color: white;
		background-color: gray;
	}
	.schedulersubtitle {
		color: black;
		background-color: lightgray;
	}
	/* .queues {
		border: 2px solid gray;
		border-radius: 10px;
	} */
	.border {
		border: 2px solid gray;
		border-radius: 10px;
	}
</style>


<div class="row" style="text-align:center">
	<div class="col-md-12">

		<input type="button" class="postsim" value="Reset" style="border-radius: 6px;" onclick="resetSimulation();">
	</div>
</div>

<div class="row" style="text-align:center">
	<div class="col-6">
		<input type="range" class="presim" id="max_jobs_slider" min="1" max="100" onchange="document.getElementById('#max_jobs_label').innerHTML = this.value;">Processes:<span id="#max_jobs_label"></span><br/>
		<input type="range" class="presim" id="max_jobs_slider" min="1" max="10" onchange="document.getElementById('#load_label').innerHTML = this.value;">Load:<span id="#load_label"></span>
	</div>
	<div class="col-6">
		System Type:
		<select id="#system_type_selector" name="system_type" class="presim" onchange="systemChanged();"></select>
	</div>
</div>
<div class="row" style="text-align:center">
	<div class="col">
		<input type="button" class="presim" value="Run" style="border-radius: 6px;" onclick="runSimulation();">
		<div id="#time_slice">Time Slice: </div>
	</div>
</div>

<div class="row" style="text-align:center">
	<div class="col-md-12">
		<input type="button" class="postsim" id="rev_all" value="|<<" style="border-radius: 6px;" onclick="revAll();">
		<input type="button" class="postsim" id="rev_one" value="|<" style="border-radius: 6px;" onclick="adjustTimeSlice(-1);">
		<input type="button" class="postsim" id="fwd_one" value=">|" style="border-radius: 6px;" onclick="adjustTimeSlice(1);">
		<input type="button" class="postsim" id="fwd_all" value=">>|" style="border-radius: 6px;" onclick="fwdAll();">
	</div>
</div>


<div class="container" id="#schedulers">
	<!-- <div class="row scheduler">
		<div class="container">
			<div class="schedulertitle">Random Scheduler</div>
			<div class="row border">
				<div class="col-10 border" id="#scheduler_9_queues">
					<div class="schedulersubtitle">Queues</div>
					<div class="row border">
						<div class="col-1 border">Pri0</div>
						<div class="col-11 border">
							<div class="row" id="#scheduler_9_queue_0">
								<div class="col"></div>
								<div class="col-1" style="border: 2px solid gray; border-radius: 4px">P12</div>
								<div class="col-1" style="border: 2px solid gray; border-radius: 4px;">P23</div>
								<div class="col-1" style="border: 2px solid orange; border-radius: 4px;">P7</div>
								<div class="col-1" style="border: 2px solid green; border-radius: 4px">P15</div>	
								<div class="col-1" style="border: 2px solid blue; border-radius: 4px">P19</div>
								<div class="col-1" style="border: 2px solid red; border-radius: 4px">P22</div>	
							</div>
						</div>
					</div>

					<div class="row border">
						<div class="col-1 border">WAIT</div>
						<div class="col-11 border">
							<div class="row" id="#scheduler_9_queue_1" style="color: lightgray;">
								<div class="col"></div>
								<div class="col-1 border">P51</div>
								<div class="col-1 border">P1</div>
								<div class="col-1 border">P38</div>	
								<div class="col-1 border">P18</div>	
							</div>
						</div>
					</div>
				</div>
				<div class="col-md-2 border" id="#scheduler_9_cpus">
					<div class="schedulersubtitle">CPUs</div>
					<div class="row">
						<div class="col border" id="#scheduler_9_cpu_0">
							CPU0<br/>
							<div style="border: 2px solid red; border-radius: 10px; text-align: center;">P22</div>
						</div>
					</div>

				</div>
			</div>
			<div class="row" style="border: 2px solid gray; border-radius: 10px">
				<div class="col">
					<div class="row">
						<div class="schedulersubtitle col">
							Statistics
						</div>
					</div>
					<div class="row">
						<div id="#scheduler_0_currentstats" class="col-6">So Far</div>
						<div id="#scheduler_0_endingstats" class="col-6">Entire Run</div>
					</div>
				</div>
			</div>
		</div>
	</div> -->
</div>

<script>

	let systems = [ 
		new System("1-CPU System", 1),
		new System("2-CPU System", 2),
		new System("4-CPU System", 4),
	]

	// let schedulers = [
	// 	new RandomScheduler("Random Scheduler", systems[0]),
	// 	new FIFOScheduler("FIFO Scheduler", systems[0]),
	// 	new RRScheduler("Round Robin Scheduler", systems[0]),
	//  new MultiFIFOScheduler("Multi FIFO Scheduler", systems[0])
	// ]

	var time_slice = 0
	let schedulers = []
	var traces = [] // Here is where we'll store the traces from the schedulers
	var runtimes = [] // How long each scheduler took to complete everything
	var max_runtime // The longest of the runtimes
	var rng_seed = 55

	resetSimulation();
	populateSystemSelector();



	addScheduler(new FIFOScheduler("FIFO Scheduler", getSelectedSystem()))
	addScheduler(new RRScheduler("Round Robin Scheduler", getSelectedSystem(), 3))
	addScheduler(new RandomScheduler("Random Scheduler", getSelectedSystem(), rng_seed))
	addScheduler(new MultiFIFOScheduler("MultiFIFOScheduler Scheduler", getSelectedSystem()))
	addScheduler(new PriorityScheduler("PriorityScheduler Scheduler", getSelectedSystem(), 3)) // MUST define the number of priority levels or it will crash

	function addScheduler(scheduler) {
		schedulers.push(scheduler)
		appendSchedulerUI(scheduler, schedulers.length-1)
	}

	function systemChanged() {
		// Notify schedulers that the system has changed (as some may need to change their queues)
		for(scheduler_num=0; scheduler_num<schedulers.length; scheduler_num++) {
			rebuildUICpuColumn(scheduler_num)
			schedulers[scheduler_num].setSystem(getSelectedSystem())
			rebuildUIQueueColumn(scheduler_num)

		}
		// Now, rebuild the queues column for each scheduler's UI, in case their queues changed
		// TODO
	}

	////////////////////////////////////////////////////////////////
	// Viewer control (fwd/rev)
	////////////////////////////////////////////////////////////////
	function adjustTimeSlice(offset) {
		console.log("Adjusting time slice by " + offset)
		time_slice += offset
		if (time_slice < 0) { time_slice = 0 }
		if (time_slice > max_runtime) { time_slice = max_runtime }
		console.log("time_slice is now " + time_slice)
		console.log("Scheduler[0]'s trace for this cycle is now : " + JSON.stringify(traces[0].trace_object_list[time_slice]))
		updateUI()
	}

	function updateUI() {
		// console.log("schedulers has " + schedulers.length + " items: " + JSON.stringify(schedulers))
		updateUITimeSlice()
		// Update each scheduler with the details of this time_slice
		for(scheduler_num=0; scheduler_num<schedulers.length; scheduler_num++) {
			updateUISchedulerQueues(scheduler_num)
			updateUISchedulerCpus(scheduler_num)
		}
	}

	function updateUITimeSlice() {
		document.getElementById("#time_slice").innerHTML = "Time Slice : " + time_slice
	}

	function getProcessBox(text) {
		var new_element = document.createElement("div")
		new_element.className = "border"
		new_element.style = "min-height: 30px;"
		new_element.appendChild(document.createTextNode(text))
		return new_element
	}

	function populateSystemSelector() {
		var selectBox = getAndEmptyElement("#system_type_selector")
		// var selectBox = document.getElementById("#system_type_selector")
		// // Clear existing box
		// while(selectBox.firstChild) {
		// 	selectBox.removeChild(selectBox.firstChild)
		// }
		for(i=0; i<systems.length; i++) {
			var new_option = document.createElement("option")
			new_option.value = i
			new_option.text = systems[i].name
			selectBox.appendChild(new_option)
		}
		selectBox.selectedIndex = 0
	}

	// function populateSchedulerSelector(scheduler_num) {
	// 	let id = `#scheduler_${scheduler_num}_selector`
	// 	console.log("ID = " + id)
	// 	var selectBox = document.getElementById(id)
	// 	// Clear existing box
	// 	while(selectBox.firstChild) {
	// 		selectBox.removeChild(selectBox.firstChild)
	// 	}
	// 	for(i=0; i<schedulers.length; i++) {
	// 		var new_option = document.createElement("option")
	// 		new_option.value = i
	// 		new_option.text = schedulers[i].name
	// 		selectBox.appendChild(new_option)
	// 	}
	// 	selectBox.selectedIndex = 0
	// }

	////////////////////////////////////////////////////////////////
	// Name generators
	////////////////////////////////////////////////////////////////
	function getSchedulerID(scheduler_num) { return `#scheduler_${scheduler_num}` }
	function getSchedulerCpusID(scheduler_num) { return `#scheduler_${scheduler_num}_cpus` }
	function getSchedulerCpuID(scheduler_num, cpu_num) { return `#scheduler_${scheduler_num}_cpu_${cpu_num}` }
	function getSchedulerQueuesID(scheduler_num) { return `#scheduler_${scheduler_num}_queues` }
	function getSchedulerQueueID(scheduler_num, queue_num) { return `#scheduler_${scheduler_num}_queue_${queue_num}` }
	function getSchedulerCurrentStatsID(scheduler_num, queue_num) { return `#scheduler_${scheduler_num}_currentstats` }
	function getSchedulerEndingStatsID(scheduler_num, queue_num) { return `#scheduler_${scheduler_num}_endingstats` }

	////////////////////////////////////////////////////////////////
	// UI Update
	////////////////////////////////////////////////////////////////
	function getAndEmptyElement(element_id) {
		console.log("Getting and emptying element for : " + element_id);
		var element = document.getElementById(element_id)
		console.log("Got : " + JSON.stringify(element));
		while(element.firstChild) {
			element.removeChild(element.firstChild)
		}
		return element
	}

	function updateUISchedulerQueue(element_id, processes) {
		// console.log("We would update element " + element_id + " with " + processes.length + " processes")
		let element = getAndEmptyElement(element_id)
		var column_pad = document.createElement("div")
		column_pad.className = "col"
		element.appendChild(column_pad)
		// We have to reverse the list because the "front" of the queue is on the right
		console.log("processes = " + JSON.stringify(processes))
		for(process_num=processes.length-1; process_num >= 0; process_num--) {
			let process = processes[process_num]
			console.log("  process = " + JSON.stringify(process))
			let process_element = document.createElement("div")
			process_element.className = "col-1 border"
			process_element.innerHTML = "P" + process.job_number
			element.appendChild(process_element)
		}
	}

	function updateUISchedulerQueues(scheduler_num) {
		// Update all of the run queues
		console.log("Updating from scheduler " + scheduler_num)
		console.log("  " + JSON.stringify(schedulers[scheduler_num]))
		for(queue_num=0; queue_num<schedulers[scheduler_num].queue_names.length; queue_num++) {
			console.log("trace queue for scheduler " + scheduler_num + " queues" + " are " + JSON.stringify(traces[scheduler_num].trace_object_list[time_slice].queues))
			updateUISchedulerQueue(
				getSchedulerQueueID(scheduler_num, queue_num),
				traces[scheduler_num].trace_object_list[time_slice].queues[queue_num]
			)
		}
		// Update the waiting list (which is numbered the next integer after the last run queue)
		updateUISchedulerQueue(
				getSchedulerQueueID(scheduler_num, schedulers[scheduler_num].queue_names.length),
				traces[scheduler_num].trace_object_list[time_slice].waiting_jobs
		)
	}

	function updateUISchedulerCpu(element_id, process) {
		console.log("updateUISchedulerCpu(" + element_id)
		let element = getAndEmptyElement(element_id)
		element.appendChild(document.createTextNode("CPU0"))
		console.log("  process = " + JSON.stringify(process))
		let process_element = document.createElement("div")
		process_element.className = "border"
		if (process == null) {
			process_element.innerHTML = "IDLE"
		} else {
			process_element.innerHTML = "P" + process.job_number
		}
		element.appendChild(process_element)
	}

	function updateUISchedulerCpus(scheduler_num) {
		for (cpu_num=0; cpu_num<getSelectedSystem().cpus; cpu_num++) {
			updateUISchedulerCpu(
				getSchedulerCpuID(scheduler_num, cpu_num),
				traces[scheduler_num].trace_object_list[time_slice].assignments[cpu_num]
			)
		}
	}

	function rebuildUICpuColumn(scheduler_num) {
		let id = getSchedulerCpusID(scheduler_num)
		console.log("ID = " + id)
		let cpuBox = getAndEmptyElement(id)
		let title_bar = document.createElement("div")
		title_bar.className = "schedulersubtitle"
		title_bar.innerText = "CPUs"
		cpuBox.appendChild(title_bar)
		let selected_system = getSelectedSystem()
		console.log(JSON.stringify(selected_system))
		for(i=0; i<selected_system.cpus; i++) {
			console.log("Adding CPU"+i)
			var row_element = document.createElement("div")
			row_element.className = "row border"

			var new_element = document.createElement("div")
			new_element.className = "col border"
			new_element.id = `#scheduler_${scheduler_num}_cpu_${i}`
			new_element.appendChild(document.createTextNode("CPU" + i))
			new_element.appendChild(getProcessBox("NOT RUNNING"))

			row_element.appendChild(new_element)

			cpuBox.appendChild(row_element)
		}
	}

	function rebuildUIQueueColumn(scheduler_num) {
		let id = getSchedulerQueuesID(scheduler_num)
		console.log("ID = " + id)
		let queuesBox = getAndEmptyElement(id)
		let title_bar = document.createElement("div")
		title_bar.className = "schedulersubtitle"
		title_bar.innerText = "Queues"
		queuesBox.appendChild(title_bar)

		console.log("scheduler_num = " + scheduler_num)
		console.log("schedulers.length = " + schedulers.length)
		let scheduler = schedulers[scheduler_num]
		for(queue_num=0; queue_num<scheduler.queues.length; queue_num++) {
			queuesBox.appendChild(buildSchedulerQueue(scheduler_num, queue_num, scheduler.queue_names[queue_num]))
		}
		queuesBox.appendChild(buildSchedulerQueue(scheduler_num, scheduler.queues.length, "WAIT"))

		// for(i=0; i<selected_system.cpus; i++) {
		// 	console.log("Adding CPU"+i)
		// 	var row_element = document.createElement("div")
		// 	row_element.className = "row border"

		// 	var new_element = document.createElement("div")
		// 	new_element.className = "col border"
		// 	new_element.id = `#scheduler_${scheduler_num}_cpu_${i}`
		// 	new_element.appendChild(document.createTextNode("CPU" + i))
		// 	new_element.appendChild(getProcessBox("NOT RUNNING"))

		// 	row_element.appendChild(new_element)

		// 	cpuBox.appendChild(row_element)
		// }

	}

	function getSelectedSystem() {
		let systemTypeSelector = document.getElementById("#system_type_selector")
		// console.log("System Type Selector index = " + systemTypeSelector.selectedIndex)
		return systems[systemTypeSelector.selectedIndex]
	}

	function buildSchedulerQueue(scheduler_num, queue_num, queue_name) {
		let row = document.createElement("div")
		row.className = "row border"
		let name_col = document.createElement("div")
		name_col.className = "col-1 border"
		name_col.textContent = queue_name
		let queue_col = document.createElement("div")
		queue_col.className = "col-11 border"
		let queue_col_row = document.createElement("div")
		queue_col_row.className = "row"
		queue_col_row.id = getSchedulerQueueID(scheduler_num, queue_num)
		queue_col.appendChild(queue_col_row)
		row.appendChild(name_col)
		row.appendChild(queue_col)
		return row
	}

	function buildUISchedulerQueues(scheduler, scheduler_num) {
		var elements = []
		let title = document.createElement("div")
		title.className = "schedulersubtitle"
		elements.push(title)
		for(queue_num=0; queue_num<scheduler.queues.length; queue_num++) {
			elements.push(buildSchedulerQueue(scheduler_num, queue_num, scheduler.queue_names[queue_num]))
		}
		elements.push(buildSchedulerQueue(scheduler_num, scheduler.queues.length, "WAIT"))
		return elements
	}

	function buildUISchedulerQueuesAndCpus(scheduler, scheduler_num, system) {
		let queues_and_cpus = document.createElement("div")
		queues_and_cpus.className = "row border"
		let queues = document.createElement("div")
		queues.className = "col-10 border"
		queues.id = getSchedulerQueuesID(scheduler_num)
		// Build the whole queue stack
		// buildUISchedulerQueues(scheduler, scheduler_num).forEach((element) => queues.appendChild(element))
		let cpus = document.createElement("div")
		cpus.className = "col-2 border"
		cpus.id = getSchedulerCpusID(scheduler_num)
		queues_and_cpus.appendChild(queues)
		queues_and_cpus.appendChild(cpus)
		return queues_and_cpus
	}

	function buildUISchedulerStatistics(scheduler_num) {
		let row = document.createElement("div")
		row.className = "row border"
		let row_col = document.createElement("div")
		row_col.className = "col"
		// Title divs
		let row_col_title = document.createElement("div")
		row_col_title.className = "row"
		let row_col_title_text = document.createElement("div")
		row_col_title_text.className = "col schedulersubtitle"
		row_col_title_text.innerText = "Statistics"
		row_col_title.appendChild(row_col_title_text)
		
		// Row with stats columns
		let row_col_row = document.createElement("div")
		row_col_row.className = "row"
		let row_col_row_current = document.createElement("div")
		row_col_row_current.className = "col-6"
		row_col_row_current.id = getSchedulerCurrentStatsID(scheduler_num)
		row_col_row_current.innerText = "Current"
		var placeholder = document.createElement("div")
		placeholder.className = "border"
		placeholder.innerText = "Imagine some stats here"
		row_col_row_current.appendChild(placeholder)

		let row_col_row_ending = document.createElement("div")
		row_col_row_ending.className = "col-6"
		row_col_row_ending.id = getSchedulerEndingStatsID(scheduler_num)
		row_col_row_ending.innerText = "Ending"
		placeholder = document.createElement("div")
		placeholder.className = "border"
		placeholder.innerText = "Imagine some stats here"
		row_col_row_ending.appendChild(placeholder)

		row_col_row.appendChild(row_col_row_current)
		row_col_row.appendChild(row_col_row_ending)
		
		row_col.appendChild(row_col_title)
		row_col.appendChild(row_col_row)

		row.appendChild(row_col)

		return row

		// <div class="row" style="border: 2px solid gray; border-radius: 10px">
		// 	 <div class="col">
		// 		<div class="row">
		// 			<div class="schedulersubtitle col">
		// 				Statistics
		// 			</div>
		// 		</div>
		// 		<div class="row">
		// 			<div id="#scheduler_0_currentstats" class="col-6">So Far</div>
		// 			<div id="#scheduler_0_endingstats" class="col-6">Entire Run</div>
		// 		</div>
		// 	</div>
		// </div>
	}

	function appendSchedulerUI(scheduler, scheduler_num) {
		console.log("appendSchedulerUI(" + scheduler_num + ")")
		let scheduler_div = document.getElementById("#schedulers")
		let scheduler_row = document.createElement("div")
		scheduler_row.className = "row scheduler"
		let scheduler_container = document.createElement("div")
		scheduler_container.className = "container"
		let scheduler_title = document.createElement("div")
		scheduler_title.className = "schedulertitle"
		scheduler_title.textContent = scheduler.name
		// let queue_and_cpus = document.createElement("div")
		// queue_and_cpus.className = "row border"
		let queues_and_cpus = buildUISchedulerQueuesAndCpus(scheduler, scheduler_num, getSelectedSystem())
		let statistics = buildUISchedulerStatistics(scheduler_num)
		statistics.className = "row"
		scheduler_container.appendChild(scheduler_title)
		scheduler_container.appendChild(queues_and_cpus)
		scheduler_container.appendChild(statistics)
		scheduler_row.appendChild(scheduler_container)
		scheduler_div.appendChild(scheduler_row)

		rebuildUICpuColumn(scheduler_num)
		rebuildUIQueueColumn(scheduler_num)
	}


	////////////////////////////////////////////////////////////////
	// Simulation Reset/Run
	////////////////////////////////////////////////////////////////
	function resetSimulation() {
		// Disable any post-simulation UI elements and enable any pre-simulation ones
		var elements = document.querySelectorAll('.presim')
		elements.forEach((element) => element.disabled = false)
		var elements = document.querySelectorAll('.postsim')
		elements.forEach((element) => element.disabled = true)

	}

	function runSimulation() {
		// Disable any pre-simulation UI elements and enable any post-simulation ones
		var elements = document.querySelectorAll('.presim')
		elements.forEach((element) => element.disabled = true)
		var elements = document.querySelectorAll('.postsim')
		elements.forEach((element) => element.disabled = false)
		// TOOD: Actually call the simulator with parameters from the UI
		console.log("Running simulation")
		traces = simulator(getSelectedSystem(), schedulers, 55)
		max_runtime = 0
		for(i=0; i<traces.length; i++) {
			runtimes[i] = traces[i].trace_object_list.length
			// Find the largest runtime
			max_runtime = runtimes[i] > max_runtime ? runtimes[i] : max_runtime
		}

		console.log("There are " + (traces.length) + " traces")
		for (i=0; i<traces.length; i++) {
			console.log("Scheduler " + i + " needed " + traces[i].trace_object_list.length + " cycles")
		}
		time_slice = 0
		updateUI()

	}



</script>
</body>
</html>

